using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using Be.Windows.Forms;
using System.Windows.Forms;
using System.Threading.Tasks;

namespace Be.HexEditor
{
    public partial class FormFixTracks : Form
    {
        private const UInt32 TEMPO = 120; // beats/minute
        private const UInt32 TICKS_PER_BEAT = 96;
        private const UInt32 MAX_EVENTS_PER_TRACK = 500000;

        private IByteProvider _byteProvider;
        private HexBox _hexBox;
        private FormFixHybridArts _parentForm;

        private UInt32 _brokenTrackLength = 0;
        public UInt32 BrokenTrackLength { get { return _brokenTrackLength; } } // property

        private UInt32 _totalTimeTicks = 0;
        public UInt32 TotalTimeTicks { get { return _totalTimeTicks; } } // property

        private UInt32 _index = 0;
        private int _initialBadIndex = -1;
        private bool _endOfTrackShiftFlag = false;

        private UInt32 _trackLength = 0;
        private UInt32 _trackFileOffset = 0;
        private UInt32 _trackNumber = 0;
        private UInt32 _trackAddr = 0;
        private UInt32 _missingByteCounter = 0;
        private string _trackName = String.Empty;

        // These are event filters that represent "allowed" midi-event codes in the
        // track. 9X is note on/off in Sync-Track and 1X is a "time-delay" 40 is tempo-track.
        // Use space to separate filters... put an X id the secont nibble is "don't care"
        // (midi-channel in 9X for instance, can be any hex digit and it's ok)
        // The filter for each track is saved in Settings for the main hex-editor project
        // as a StringCollection called "Filters" - this means filters are saved only for the
        // current song you are fixing - fix that file completely before starting the next
        public string EventFilters { get; set; } = "9X 10";

        public FormFixTracks(FormFixHybridArts parentForm)
        {
            InitializeComponent();

            _parentForm = parentForm;
            _hexBox = _parentForm._hexBox;
            _byteProvider = _hexBox.ByteProvider;
        }

        private void FormFixTracks_Load(object sender, EventArgs e)
        {
        }

        private void FormFixTracks_Shown(object sender, EventArgs e)
        {
            AnalyzeTrack(); // check for bad events
        }

        // Call this before the dialog is shown...
        public UInt32 LoadTrack(string trackName, UInt32 trackLength, UInt32 trackAddr, UInt32 trackFileOffset, UInt32 trackNumber, string eventFilters)
        {
            // set globals
            _trackName = trackName;
            _trackLength = trackLength;
            _trackAddr = trackAddr;
            _trackFileOffset = trackFileOffset;
            _trackNumber = trackNumber;
            EventFilters = eventFilters;

            return LoadTrack();
        }

        private void buttonReapplyFilters_Click(object sender, EventArgs e)
        {
            AnalyzeTrack();
        }

        private void buttonReload_Click(object sender, EventArgs e)
        {
        }

        // HOW WE KNOW HOW MANY BYTES ARE MISSING IN THE TRACK (1A or 0D are the only possible bytes)... We have the original track
        // length from the repaired "lengths" table... and we can count the actual # byts that are in the track using the end-of-track
        // "00 00 00 00" marker...
        public UInt32 LoadTrack()
        {
            if (_trackLength < 4)
                return 0;

            // disable event handler (if enabled)
            this.dataGridView1.CellEndEdit -= new System.Windows.Forms.DataGridViewCellEventHandler(this.dataGridView1_CellEndEdit);

            try
            {
                this.Text = "Track " + (_trackNumber + 1) + ": " + _trackName;
                textBoxTrackLength.Text = _trackLength.ToString();
                textBoxTableOffset.Text = String.Format("{0:X8}", _trackAddr);
                textBoxFileOffset.Text = String.Format("{0:X8}", _trackFileOffset);
                textBoxFilters.Text = EventFilters;
                labelEndOfTrackShift.Text = "";

                UInt32 totalEvents = _trackLength / sizeof(UInt32);
                if (totalEvents > MAX_EVENTS_PER_TRACK)
                {
                    MessageBox.Show("totalEvents (" + totalEvents + ") exceeds limit of " + MAX_EVENTS_PER_TRACK + " events per track!");
                    return 0;
                }

                // clear out previous rows (phenomenonally SLOW :-( )
                //dataGridView1.Rows.Clear();
                //dataGridView1.Refresh(); // make sure its updated... we were getting an endless load loop when buttonReload pressed...

                _totalTimeTicks = 0;
                _missingByteCounter = 0;
                _index = 0;
                _endOfTrackShiftFlag = false;
                _brokenTrackLength = 0;
                _initialBadIndex = -1;

                // add trackLength/4 event-rows (include the terminating 00 00 00 00)
                dataGridView1.RowCount = (int)totalEvents;

                // display event (row) numbers
                foreach (DataGridViewRow r in dataGridView1.Rows)
                    dataGridView1.Rows[r.Index].HeaderCell.Value = (r.Index + 1).ToString();

                // read _hexBox at track
                int endOfTrackCounter = 0;
                UInt32 acc = 0;
                bool bHaveEndOfTrackMarker = false;
                UInt32 addr = _trackFileOffset;
                UInt32 fileLen = (UInt32)_byteProvider.Length;
                int maxRows = dataGridView1.Rows.Count;
                byte val = 0;

                if (maxRows != totalEvents)
                {
                    MessageBox.Show("maxRows should be " + maxRows + " and is: " + totalEvents);
                    return 0;
                }

                string[] filterTokens = EventFilters.Split(new char[] { ' ', ',' });

                bool disableEOTMS = checkBoxDisableEOTMS.Checked; // flag to disable auto end-of-track-marker shift right

                foreach (DataGridViewRow r in dataGridView1.Rows)
                {
                    for (int ii = 0; ii < 4; ii++)
                    {
                        // set an end-of-track flag if we hit 4 consecutive 00s
                        if (!bHaveEndOfTrackMarker)
                        {
                            if (addr < fileLen && addr < _trackFileOffset + _trackLength)
                            {
                                val = _byteProvider.ReadByte(addr++);
                                _brokenTrackLength++;

                                if (_brokenTrackLength > MAX_EVENTS_PER_TRACK)
                                {
                                    MessageBox.Show("_brokenTrackLength (" + _brokenTrackLength + ") exceeds limit of " + MAX_EVENTS_PER_TRACK + " events per track!");
                                    return 0;
                                }

                                if (val == 0)
                                {
                                    if (++endOfTrackCounter >= 4)
                                    {
                                        // a little hitch... it's possible for a 00 timestamp to preceed
                                        // the 00 00 00 00 end-of-track marker. So we need to detect this
                                        // situation and "slide" the window one address higher if the next byte
                                        // is 0 and _brokenTrackLength == trackLength-1

                                        // Note - we don't want to move the window if the NEXT track starts
                                        // with 00! So imagine a track with a lot of missing bytes but still with
                                        // 00 00 00 00 at the "end"... and there's a 00 timestamp before it and
                                        // possibly the next track starts with 00... _brokenTrackLength == trackLength-1
                                        // won't work...

                                        // let's go on the premise that the end-of-track marker will be centered between
                                        // two 4-byte events with an event-code that is allowed for this track's filter-string...
                                        // One or both surrounding events "could" be damaged (missing one or more bytes)...

                                        // Another little gottcha - checking for an allowed event-code at addr-5 won't
                                        // work because the timecode byte can look like a note event (have a 9D I'm seeing now!)

                                        // Having trouble now with a false "need to shift" caused by the fact that 3 bytes missing
                                        // prior to a plain old 00 00 00 00 (then 00 00 10 f0 starts new track)  make the position of
                                        // the event-code impossible(?) to predict... 
                                        if (!_endOfTrackShiftFlag && !disableEOTMS && addr < fileLen && addr >= 7)
                                        {
                                            byte byteAfterMarker = _byteProvider.ReadByte(addr);
                                            byte byteBeforeMarker = _byteProvider.ReadByte(addr - 5); // this HAS to be an event-code if we must slide forward one...
                                                                                                      // BUT - it MIGHT be a time-code that looks like an event-code... so we need to check the
                                                                                                      // byte before that too - if we need to slide this code should not be an event-code
                                            byte byteBeforeThat = _byteProvider.ReadByte(addr - 6);

                                            if (byteAfterMarker == 0 && IsAllowedEventCode(String.Format("{0:X2}", byteBeforeMarker), filterTokens) &&
                                                !IsAllowedEventCode(String.Format("{0:X2}", byteBeforeThat), filterTokens))
                                            {
                                                DialogResult result1 = MessageBox.Show("End-of-track marker:\n\n" +
                                                    String.Format("{0:X8}\n", GetWord(addr - 8 + 1)) + 
                                                    String.Format("{0:X8}\n", GetWord(addr - 4 + 1)) + 
                                                    String.Format("{0:X8} (next track)\n\n", GetWord(addr - 0 + 1)) +
                                                    "If above is OK choose YES otherwise choose NO",
                                                    "Song: " + _trackName, MessageBoxButtons.YesNo, MessageBoxIcon.Warning, MessageBoxDefaultButton.Button1);

                                                if (result1 == DialogResult.Yes)
                                                {
                                                    endOfTrackCounter--; // go one more byte
                                                    _endOfTrackShiftFlag = true;
                                                }
                                                else
                                                    bHaveEndOfTrackMarker = true;
                                            }
                                            else
                                                bHaveEndOfTrackMarker = true;
                                        }
                                        else
                                            bHaveEndOfTrackMarker = true;
                                    }
                                }
                                else if (endOfTrackCounter > 0)
                                    endOfTrackCounter = 0;
                            }
                            else
                                val = 0;
                        }
                        else
                            val = 0;

                        // accumulate 4-byte words and add them to the gridView
                        acc <<= 8;
                        acc |= val;
                    }

                    dataGridView1.Rows[r.Index].Cells[0].Value = String.Format("{0:X8}", acc);

                    acc = 0;
                }

                RefreshTimes();

                _missingByteCounter = _trackLength - _brokenTrackLength;
                textBoxMissingByteCount.Text = _missingByteCounter.ToString();

                if (_endOfTrackShiftFlag)
                    labelEndOfTrackShift.Text = "Shifted End-of-track marker!";
                else
                    labelEndOfTrackShift.Text = "";

                if (!bHaveEndOfTrackMarker)
                    MessageBox.Show("This track has no 00 00 00 00 end-of track marker!");

            }
            finally
            {
                // re-enable event handler
                this.dataGridView1.CellEndEdit += new System.Windows.Forms.DataGridViewCellEventHandler(this.dataGridView1_CellEndEdit);
            }
            return _brokenTrackLength;
        }

        private void AnalyzeTrack()
        {
            // Set the yellow color on any cells that have a misalligned event code (xx 00 EE xx). Valid events
            // are checked against the filter-list (user can set via textBoxFilters)
            _initialBadIndex = RefreshColors(0);
            RefreshTimes();
            ScrollToYellow();
        }

        private void buttonAutoFix_Click(object sender, EventArgs e)
        {
            if (dataGridView1.Rows.Count <= 0)
                return;

            int index;

            // When the initial track-data loaded we probably called RefreshColorsAndTimes(0)... and if it found a bad byte
            // and if it inserted a 1A in the location before it... we need to propogate that byte through the remainder of the track
            // and begin here at the following index...
            if (_initialBadIndex < 0 || !checkBoxAutoInsert1A.Checked)
                index = 0;
            else
            {
                index = _initialBadIndex;
                ShiftDataAfterEdit(dataGridView1, index - 1, 0); // decrements _missingByteCounter
                // index++; Go ahead and re-check same event again (see below!)
            }

            // re-enable auto-insert 1A
            if (!checkBoxAutoInsert1A.Checked)
                checkBoxAutoInsert1A.Checked = true;

            for (;;)
            {
                // Search 4-byte event-codes (next to rightmost byte) in column 0 until an event code is detected
                // that does not match one of the Allowed Event Codes, auto insert 1A into the event that preceeds
                // that code.
                index = QuickCheckForBadEventCode(index);

                // -3 = abort, -2 error, -1 events from index to end all ok, 0-N bad event index
                // if event 0 is bad we cant add 1A to a previous event because there is none!
                if (index < 1) // quit if error, user-cancel, all remaining events are ok... or if byte at index 0 is bad.
                    break;

                if (_missingByteCounter == 0)
                {
                    // if the routines fixed all expected bad bytes we should have broken out above
                    // at the same time _missingByteCounter decrements to 0 - and never get here...
                    //
                    // unless possibly the end-of-track-marker is skewed by one byte and _brokenTrackLength
                    // is too short by one...
                    //
                    // or if the track is totally corrupt in some other way than one missing byte in an event
                    // if there was both a 0D and 1A in a single event we have problems!
                    MessageBox.Show("We found more broken bytes than expected. _brokenTrackLength may be short by one." +
                        " Try checking \"Disable End-Of-Marker Shift\". Or - may need to add an event-type to the Allowed Types box?\n\n" +
                        "_brokenTrackLength = " + _brokenTrackLength + ", trackLength = " + _trackLength);
                    break;
                }

                // here we have a bad event code (out of alignment...) at "index"
                // and we've inserted a 1A at (index-1) - now we need to ripple-propogate that byte down
                // through every row (4-byte event code)...
                if (checkBoxAutoInsert1A.Checked)
                    ShiftDataAfterEdit(dataGridView1, index - 1, 0); // decrements _missingByteCounter

                // Found that we DO need to recheck same event if it was missing more than one byte and we just insertes one
                // of them... SO MUST recheck!
                //index++; // don't need to recheck event we just fixed!
            }

            // -1 if all good, -2 if error, -3 if canceled
            if (index == 0)
                MessageBox.Show("Bad byte found at index 0! (need to hand-edit this one, nothing above it to insert 1A/0D into...)");
            //else if (index == -1)
            //    MessageBox.Show("Track is OK!");
            else if (index == -2)
                MessageBox.Show("Error in QuickCheckForBadEventCode()!");
            else if (index == -3)
                MessageBox.Show("Auto-Fix Canceled!");
            else
            {
                // if all went ok _missingByteCounter will be 0
                _initialBadIndex = RefreshColors(0); // one last check of entire track and set times and colors
                RefreshTimes();
                ScrollToYellow();
            }
        }

        /// <summary>
        /// Fast "no-frills" version of RefreshColorsAndTimes() that returns the index of the first
        /// bad event encountered or -1 if all good, -2 if error, -3 if canceled. Always does Auto-Fill of 1A
        /// to become the timestamp of the event that preceeds the bad one. Need to call ShiftDataAfterEdit
        /// </summary>
        private int QuickCheckForBadEventCode(int startOffset)
        {
            string[] filterTokens = EventFilters.Split(new char[] { ' ', ',' });

            for (int ii = startOffset; ii < dataGridView1.Rows.Count; ii++)
            {
                string eventCode = dataGridView1.Rows[ii].Cells[0].Value.ToString();

                if (eventCode.Length != 8)
                {
                    MessageBox.Show("Cancelling due to bad event length at: " + (ii+1).ToString() + "\nEvent: \"" + eventCode.ToString() + "\"");
                    return -3;
                }
                else if (eventCode.Length == 8 && eventCode != "00000000")
                {
                    // -3 = abort, -2 error, -1 this event is ok, 0-N bad event index
                    int ret = DetectBadEventCode(ii, eventCode, filterTokens);
                    if (ret != -1) return ret; // return unless code is -1
                }
            }

            return -1; // no errors
        }

        /// <summary>
        /// Insert 1A at the timestamp position of the 4-byte hex event at index
        /// Returns -1 if 1A inserted, -2 if error, 0 if not inserted
        /// </summary>
        private int Insert1A(int index)
        {
            // For a note-event, 1A and 0D are probably not velocity or a note-codes and 0D is
            // is a pretty short time-stamp... so the most-likley missing code is a 1A for the
            // time-stamp in the previous event, For other event-types, a missing time-stamp
            // is also a fair guess so lets try it...
            try
            {
                string eventCode = dataGridView1.Rows[index].Cells[0].Value.ToString();

                if (eventCode.Length != 8 || eventCode == "00000000")
                    return 0; // don't shuffle bytes... no insertion

                if (checkBoxAutoInsert1A.Checked)
                    dataGridView1.Rows[index].Cells[0].Value = eventCode.Insert(6, "1A");

                return -1; // code inserted, ok to right-shift byte through remaining events
            }
            catch { }

            return -2; // error
        }

        /// <summary>
        /// Searches events from startOffset for a bad event-code, highlights it in yellow
        /// and inserts a 1A in the previous event
        /// </summary>
        private int RefreshColors(int startOffset)
        {
            // Note: badEventCodeCounter is only counting the number of "yellow" cells - where the event-code
            // does not line-up - this is not the same as the number of missing bytes in the track which
            // is computed via _trackLength - _brokenTrackLength (see above)
            
            int firstIndex = -1;

            string[] filterTokens = EventFilters.Split(new char[] { ' ', ',' });

            // calculate delta times and cumulative time
            // NOTE: have to iterate through them all because of cumulative time computation (below)!
            for (int ii = startOffset; ii < dataGridView1.Rows.Count; ii++)
            {
                string eventCode = dataGridView1.Rows[ii].Cells[0].Value.ToString();

                if (eventCode.Length != 8 || eventCode == "00000000")
                    dataGridView1.Rows[ii].Cells[0].Style.BackColor = Color.LightGray;
                else
                {
                    // -1 = keep processing, -3 = abort, -2 = error, 0-N is index
                    int ret = DetectBadEventCode(ii, eventCode, filterTokens);

                    if (ret == -3)
                    {
                        MessageBox.Show("Refresh Colors Cancelled!");
                        break; // user-cancel
                    }

                    if (ret == -2)
                    {
                        MessageBox.Show("Refresh Colors Error!");
                        dataGridView1.Rows[ii].Cells[0].Style.BackColor = Color.Red; // error
                        break;
                    }

                    if (ret >= 0)
                    {
                        // bad event found
                        dataGridView1.Rows[ii].Cells[0].Style.BackColor = Color.Yellow;
                        firstIndex = ii;
                        break;
                    }

                    // ret == -1 (no error so go check next event)
                    dataGridView1.Rows[ii].Cells[0].Style.BackColor = Color.White; // event-code position is ok
                }
            }

            return firstIndex;
        }

        /// <summary>
        /// Scans events for a bad code as determined from the Allowed Codes filter-list.
        /// Can prompt the user to add a new Allowed Code to the list and auto-inserts a 1A
        /// in the preceeding event.
        ///
        /// Returns: -3 = abort, -2 error, -1 this event is ok, 0-N bad event index
        /// </summary>
        private int DetectBadEventCode(int ii, string eventCode, string[] filterTokens)
        {
            string sCodeNorm, sCodeShift;
            bool bIsAllowedNorm, bIsAllowedShift;

            // "vvnnEEtt" sCodeA will have EE, sCodeB will have nn (usually a note if EE is 9X)
            sCodeNorm = eventCode.Substring(4, 2);
            bIsAllowedNorm = IsAllowedEventCode(sCodeNorm, filterTokens);
            sCodeShift = eventCode.Substring(2, 2);
            bIsAllowedShift = IsAllowedEventCode(sCodeShift, filterTokens);

            // Have four possibilities:
            // 1) !bIsAllowedShift && !bIsAllowedNorm => Ask user if we should add sCodeA to Allowed list
            // 2) !bIsAllowedShift && bIsAllowedNorm => OK! Move on to next event
            // 3) bIsAllowedShift && !bIsAllowedNorm => Insert 1A as the new timestamp for the previous event and ripple bytes through
            // 4) bIsAllowedShift && bIsAllowedNorm => Ask user if sCodeA might be a timestamp that just happens to also pass the allowed-events
            //                                   filter... if not do (2) - if it is, do (3)

            if (!bIsAllowedShift && !bIsAllowedNorm) // ask if we should add code to allowed-list
            {
                // allow some space at top
                int idx = ii - 10;
                if (idx < 0)
                    idx = 0;
                dataGridView1.Rows[ii].Cells[0].Style.BackColor = Color.Yellow;
                dataGridView1.FirstDisplayedScrollingRowIndex = idx; // scroll to index
                dataGridView1.Refresh();
                this.Update();

                string sCodeTwoShift = eventCode.Substring(0, 2);
                bool bIsAllowedTwoShift = IsAllowedEventCode(sCodeTwoShift, filterTokens);

                DialogResult result1;

                if (bIsAllowedTwoShift)
                {
                    result1 = MessageBox.Show("Might be missing TWO bytes before " + sCodeTwoShift.ToUpper() + " ..." +
                        "\n\nIndex: " + (ii + 1).ToString() + "\nEvent: " + eventCode +
                        "\n\nClick Cancel to disable \"Auto Insert 1A\" and hand-edit," +
                        "\nClick OK to add " + sCodeNorm.ToUpper() + " to Allowed Event Codes and continue.",
                        "Song: " + _trackName, MessageBoxButtons.OKCancel, MessageBoxIcon.Warning, MessageBoxDefaultButton.Button1);
                }
                else
                {
                    result1 = MessageBox.Show("Might have a new event-code " + sCodeTwoShift.ToUpper() + " (not in Allowed Event Codes List)..." +
                        "\n\nIndex: " + (ii + 1).ToString() + "\nEvent: " + eventCode +
                        "\n\nClick Cancel to disable \"Auto Insert 1A\" and hand-edit," +
                        "\nClick OK to add " + sCodeNorm.ToUpper() + " to Allowed Event Codes and continue.",
                        "Song: " + _trackName, MessageBoxButtons.OKCancel, MessageBoxIcon.Warning, MessageBoxDefaultButton.Button1);

                }

                // disable auto-insert 1A and abort...
                if (result1 == DialogResult.Cancel)
                {
                    checkBoxAutoInsert1A.Checked = false;
                    return -3; // abort
                }

                // Add a new event filter and keep going...
                EventFilters += " " + sCodeNorm.ToUpper();
                textBoxFilters.Text = EventFilters;
                filterTokens = EventFilters.Split(new char[] { ' ', ',' });
            }
            else if (bIsAllowedShift && !bIsAllowedNorm) // insert 1A
            {
                // returns -1 if 1A inserted, -2 if error, 0 if not inserted
                int ret = Insert1A(ii - 1);
                if (ret == -1) return ii; // return index of bad event-code (1A has been inserted in event at ii-1)
                if (ret == -2) return -2; // error
            }
            else if (bIsAllowedShift && bIsAllowedNorm) // might have timestamp left-shifted into the event-code position!
            {
                // allow some space at top
                int idx = ii - 10;
                if (idx < 0)
                    idx = 0;
                dataGridView1.Rows[ii].Cells[0].Style.BackColor = Color.Yellow;
                dataGridView1.FirstDisplayedScrollingRowIndex = idx; // scroll to index
                dataGridView1.Refresh();
                this.Update();

                DialogResult result1 = MessageBox.Show("Event-code looks OK but it may be a time-stamp left-shifted into the event-code position..." +
                    "\n\nIndex: " + (ii + 1).ToString() +
                    "\nEvent: " + eventCode +
                    "\n\nIs event OK?\n(Answering NO will insert a 1A as previous event's timestamp!)",
                    "Song: " + _trackName, MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning, MessageBoxDefaultButton.Button1);

                if (result1 == DialogResult.Cancel)
                    return -3; // abort

                if (result1 == DialogResult.No)
                {
                    // returns -1 if 1A inserted, -2 if error, 0 if not inserted
                    int ret = Insert1A(ii - 1);
                    if (ret == -1) return ii; // return index of bad event-code (1A has been inserted in event at ii-1)
                    if (ret == -2) return -2; // error
                }
            }

            if (dataGridView1.Rows[ii].Cells[0].Style.BackColor != Color.White)
                dataGridView1.Rows[ii].Cells[0].Style.BackColor = Color.White;

            return -1; // (!bIsAllowedShift && bIsAllowedNorm) this event looks ok, so keep going...
        }

        /// <summary>
        /// Gets the timestamp from last byte of event (column 0) and displays it in ticks (column 2) and sums the delta-times (column 1)
        /// </summary>
        private void RefreshTimes()
        {
            UInt32 deltaTime;
            _totalTimeTicks = 0;

            for (int ii = 0; ii < dataGridView1.Rows.Count; ii++)
            {
                // convert hex to UInt32 then mask out upper three bytes to leave time-stamp byte
                try { deltaTime = Convert.ToUInt32(dataGridView1.Rows[ii].Cells[0].Value.ToString(), 16); } // 16 is base
                catch { deltaTime = 0; }
                deltaTime &= 0x000000ff;
                _totalTimeTicks += deltaTime;
                dataGridView1.Rows[ii].Cells[2].Value = String.Format("{0:f3}", (double)(deltaTime * 60) / (double)(TEMPO * TICKS_PER_BEAT));
                dataGridView1.Rows[ii].Cells[1].Value = String.Format("{0:f3}", (double)(_totalTimeTicks * 60) / (double)(TEMPO * TICKS_PER_BEAT));
            }
        }

        /// <summary>
        /// Called when you press enter after clicking a cell twice to edit it
        /// </summary>
        private void dataGridView1_CellEndEdit(object sender, DataGridViewCellEventArgs e)
        {
            if (sender is DataGridView)
            {
                DataGridView dgv = sender as DataGridView;

                if (dgv != null)
                {
                    ShiftDataAfterEdit(dgv, e.RowIndex, e.ColumnIndex);

                    // don't do this if manual edit mode - very annoying!
                    if (checkBoxAutoInsert1A.Checked)
                    {
                        _initialBadIndex = RefreshColors(e.RowIndex); // check for bad bytes and reset colors on column 0 (4-byte hex event) cells
                        ScrollToYellow();
                        RefreshTimes();
                    }
                }
            }
        }

        /// <summary>
        /// Shifts byte in at msb of hex string and returns a byte shifted out the lsb
        /// </summary>
        private void ShiftDataAfterEdit(DataGridView dgv, int rowIndex, int columnIndex)
        {
            // disable event handler (if enabled)
            dgv.CellEndEdit -= new System.Windows.Forms.DataGridViewCellEventHandler(this.dataGridView1_CellEndEdit);

            try
            {
                if (dataGridView1.Rows[rowIndex].Cells[columnIndex].Style.BackColor != Color.White)
                    dataGridView1.Rows[rowIndex].Cells[columnIndex].Style.BackColor = Color.White; // clear yellow color

                string s = dgv.Rows[rowIndex].Cells[columnIndex].Value.ToString();

                string[] filterTokens = EventFilters.Split(new char[] { ' ', ',' });

                byte newByte = 0;

                if (s.Length == 8)  // handle case of user hand-editing a location (just save it back)
                    dgv.Rows[rowIndex].Cells[columnIndex].Value = s;
                else if (s.Length == 10) // ripple bytes down if two chars (one hex byte) added
                {
                    // walk forward, from this point on, propogating the rightmost byte of each 4-byte word
                    for (int ii = rowIndex; ii < dgv.Rows.Count; ii++)
                    {
                        s = dgv.Rows[ii].Cells[columnIndex].Value.ToString();

                        if (ii == rowIndex)
                        {
                            newByte = Convert.ToByte(s.Substring(8, 2), 16);  // save lsb (rightmost byte)
                            s = s.Substring(0, 8); // cut off lsb of value we just inserted text into
                        }
                        else
                            newByte = ShiftRight(ref s, newByte);

                        dgv.Rows[ii].Cells[columnIndex].Value = s;
                    }

                    // decrement counter
                    if (_missingByteCounter > 0)
                    {
                        _missingByteCounter--;
                        textBoxMissingByteCount.Text = _missingByteCounter.ToString();
                    }
                }
                else if (s.Length == 6) // ripple bytes up if two chars (one hex byte) deleted
                {
                    // walk backward, from end to the edit-location, propogating the lefttmost byte of each 4-byte word
                    // (we feed in a 00 at the end of the list to kick things off)
                    for (int ii = dgv.Rows.Count - 1; ii >= rowIndex; ii--)
                    {
                        s = dgv.Rows[ii].Cells[columnIndex].Value.ToString();

                        if (ii == rowIndex)
                            dgv.Rows[ii].Cells[columnIndex].Value = s + String.Format("{0:X2}", newByte); // back to one we deleted two hex chars from
                        else
                        {
                            newByte = ShiftLeft(ref s, newByte);
                            dgv.Rows[ii].Cells[columnIndex].Value = s;
                        }
                    }

                    // increment counter
                    _missingByteCounter++;
                    textBoxMissingByteCount.Text = _missingByteCounter.ToString();
                }
            }
            catch
            {
                MessageBox.Show("Exception in CellEndEdit!");
            }
            finally
            {
                // re-enable event handler
                dgv.CellEndEdit += new System.Windows.Forms.DataGridViewCellEventHandler(this.dataGridView1_CellEndEdit);
            }
        }

        // shifts byte in at msb of hex string and returns a byte shifted out the lsb
        private byte ShiftRight(ref string s, byte newByte)
        {
            byte retByte = 0;
            int len = s.Length;

            if (len >= 2)
            {
                len -= 2;

                try
                {
                    retByte = Convert.ToByte(s.Substring(len, 2), 16);  // save lsb (rightmost byte)
                    s = String.Format("{0:X2}", newByte) + s.Substring(0, len); // push in new byte at msb (leftmost)
                }
                catch { }
            }
            return retByte;
        }

        // shifts byte in at lsb of hex string and returns a byte shifted out the msb
        private byte ShiftLeft(ref string s, byte newByte)
        {
            byte retByte = 0;
            int len = s.Length;

            if (len >= 2)
            {
                len -= 2;

                try
                {
                    retByte = Convert.ToByte(s.Substring(0, 2), 16);  // save msb (lefttmost byte)
                    s = s.Substring(2, len) + String.Format("{0:X2}", newByte); // push in new byte at lsb (rightmost)
                }
                catch { }
            }
            return retByte;
        }

        private void ScrollToYellow()
        {
            foreach (DataGridViewRow r in dataGridView1.Rows)
            {
                if (r.Cells[0].Style.BackColor == Color.Yellow)
                {
                    int idx = r.Index - 10;

                    if (idx < 0)
                        idx = r.Index;

                    dataGridView1.FirstDisplayedScrollingRowIndex = idx;
                    break;
                }
            }
        }

        /// <summary>
        /// Returns true if sIn has a midi-event we want to recognize
        /// </summary>
        private bool IsAllowedEventCode(string sIn, string[] filterTokens)
        {
            sIn = sIn.ToLower();

            // want to return true if sIn has a match to one of the filter-strings
            // in the list. Example: pass "97" in sIn and true is returned because
            // filterTokens has '9X' in it (X is don't care)
            for (int ii = 0; ii < filterTokens.Length; ii++)
            {
                filterTokens[ii] = filterTokens[ii].ToLower();

                bool bMatch1 = false;
                bool bMatch2 = false;

                if (filterTokens[ii].Length == 2 && sIn.Length == 2)
                {
                    if (filterTokens[ii][0] == 'x' || filterTokens[ii][0] == sIn[0])
                        bMatch1 = true;
                    if (filterTokens[ii][1] == 'x' || filterTokens[ii][1] == sIn[1])
                        bMatch2 = true;
                    if (bMatch1 && bMatch2)
                        return true;
                }
            }
            return false;
        }

        private void buttonOk_Click(object sender, EventArgs e)
        {
            if (_missingByteCounter == 0)
                TrackCopy(); // put our data from column 0 on the clipboard
            else
            {
                MessageBox.Show("Track is not fixed! Missing Bytes: " + _missingByteCounter);
                DialogResult = DialogResult.Cancel;
            }
        }

        public void TrackCopy()
        {
            if (_brokenTrackLength == 0 || _trackFileOffset == 0) return;

            // put bytes into buffer
            UInt32 val;
            UInt32 offset = 0;
            byte[] buffer = new byte[_trackLength];
            foreach (DataGridViewRow r in dataGridView1.Rows)
            {
                try { val = Convert.ToUInt32(dataGridView1.Rows[r.Index].Cells[0].Value.ToString(), 16); }
                catch { val = 0; }

                if (offset <= _trackLength-4)
                {
                    for (int ii = 3; ii >= 0; ii--)
                    {
                        buffer[offset + ii] = (byte)(val & 0xff);
                        val >>= 8;
                    }

                    offset += 4;
                }
                else
                {
                    MessageBox.Show("Copy() buffer overrun!");
                    return;
                }
            }

            DataObject da = new DataObject();

            // set string buffer clipbard data
            string sBuffer = System.Text.Encoding.ASCII.GetString(buffer, 0, buffer.Length);
            da.SetData(typeof(string), sBuffer);

            //set memorystream (BinaryData) clipboard data
            System.IO.MemoryStream ms = new System.IO.MemoryStream(buffer, 0, buffer.Length, false, true);
            da.SetData("BinaryData", ms);

            Clipboard.SetDataObject(da, true);
        }

        private void textBoxFilters_TextChanged(object sender, EventArgs e)
        {
            EventFilters = textBoxFilters.Text;
        }

        private UInt16 GetShort(long addr)
        {
            UInt16 acc = 0;
            for (int ii = 0; ii < 2; ii++)
            {
                acc <<= 8;
                acc |= _byteProvider.ReadByte(addr++);
            }
            return acc;
        }

        private UInt32 GetWord()
        {
            UInt32 acc = 0;
            for (int ii = 0; ii < 4; ii++)
            {
                acc <<= 8;
                acc |= _byteProvider.ReadByte(_index++);
            }
            return acc;
        }

        private UInt32 GetWord(long addr)
        {
            UInt32 acc = 0;
            for (int ii = 0; ii < 4; ii++)
            {
                acc <<= 8;
                acc |= _byteProvider.ReadByte(addr++);
            }
            return acc;
        }

        private void PutShort(long addr, UInt16 value)
        {
            for (int ii = 0; ii < 2; ii++)
            {
                _byteProvider.WriteByte(addr + 1 - ii, (byte)(value & 0x00ff));
                value >>= 8;
            }
        }

        private void PutWord(long addr, UInt32 value)
        {
            for (int ii = 0; ii < 4; ii++)
            {
                _byteProvider.WriteByte(addr + 3 - ii, (byte)(value & 0x000000ff));
                value >>= 8;
            }
        }
    }
}
